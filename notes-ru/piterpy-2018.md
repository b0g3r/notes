
## Тезисы, план

1. О важности стандартизации и документирования перед написанием кода
    1. Проблемы в PHP
    1. Проблемы с API одного банка
    1. PEP -- хорошо. Делайте так.
1. О разделении кода на компоненты
    1. Миксины
        1. Миксины должны быть раньше родителя
        1. Миксины не должны ни от чего наследоваться
        1. Как работает в Python MRO
    1. Контрактное программирование
    1. Аспектно-ориентированное программирование
1. Про MVC
    1. Как выглядит MVC
    1. Как это выглядит в Django: MVT
    1. Как сделать лучше: DjBurger
1. Что осталось за бортом, какие выводы

## 1.

Всем привет. Меня зовут Грам, а эту курицу -- мисс Ревью. И я отдам её тому, кто после выступления задаст самый интересный вопрос. Ну а расскажем мы про хороший, плохой и ужасный код.

## 2.

Но для начала давайте немного о том, зачем я это всё рассказываю. Я видел много плохого кода. Очень много. 4 года, ещё в лицее и университете, я делал сайты на PHP за 3-5 тысяч рублей. Часто приходилось дописывать код за такими же студентами, как я, и попадались действительно запутанные вещи.

Затем я работал в компании Smena. Нам от предыдущих разработчиков достался огромный legacy монолит на django, из которого мы всеми силами делали проект, который будет легко и не больно сопровождать. И, мне кажется, мы многого добились.

Ну а сейчас я работаю в компании Cindicator. И первая задача, с которой я столкнулся -- переписывание кода, написанного MLщиками. Надо сказать, это производит неизгладимое впечатление на психику. Само ядро машинного обучения я почти не трогал, там очень много крутой магии, а вот механизмы, которые с этим работают, пришлось переписать практически с нуля.

## 3.

И вот я здесь. И первое, о чём я хочу вам рассказать -- PHP. Слева вы видите взгляд Марка Цукерберга, когда ему напомнили, что он написал крупнейшую соц. сеть на PHP. А справа -- причины, почему PHP не люблю я.

1. Во-первых, алиасы. Есть много способов сделать одно и то же, и, чтобы читать чужой код, вам нужно знать каждый.
2. Во-вторых, strstr и stristr делают одно и то же: ищут подстроку в строке. Просто один делает это регистронезависимо. Мы привыкли, что обычно подобные вещи делает одна функция, которая чуть меняет своё поведение в зависимости от переданного параметра. Но в PHP это не так, тут для всего отдельная функция.
3. В-третьих, нет порядка в именовании функций. Они могут содержать нижний прочерк, а могут и не содержать. Вы не узнаете этого, пока не заглянете в документацию или просто не выучите написание каждой.
4. Вы думали, все строковые функции содержат в названии str? А вот и нет. Вот функция trim, которая убирает пробельные символы из начала и конца строки. Она работает только со строками. Зато функция strlen может принять, например, число. К тому же, она считает не количество символов, как хотелось бы, а количество байт.

## 4.

Ну и отдельная тема -- приведение типов. Вот пример, когда две разных строки интерпретируются как два числа с плавающей точкой и приводятся к нулю. В результате имеем нестрогое равенство.

Причины этих проблем кроются в том, что PHP задумывался как простенький шаблонизатор для удобного написания персональной странички, а не как язык для крупнейшей соц. сети в мире. И даже назывался он изначально Personal Home Page.

## 5.

Первая версия PHP выглядела как-то так. Она умела подключать другие PHP-шаблоны, выполнять SQL-запросы, и имела даже проверку условий. Пример взят с официального сайта PHP. Кроме неинтуитивности кода и отсутствия Тьюринг полноты, кто видит здесь серьезную такую проблему?

Да, это SQL-инъекция. Первый же пример позволяет дропнуть всю вашу базу данных.

После этого PHP много раз переписывался с нуля, но никто так и не подошёл к этому процессу серьезно, никто не исправил те проблемы, о которых я рассказал.

## 6.

Но это всё было давно и как будто бы не должно нас беспокоить. Мы же пишем на python. Но не так давно мне пришлось интегрировать в проект работу с API одного банка. Название банка зашифровано, любые совпадения случайны. Так вот, этот API писал кот.

1. Во-первых, названия одних и тех же полей могут приходить в разных регистрах для разных методов. Это путает и усложняет работу с полями.
2. Во-вторых, как узнать, что всё хорошо? Конечно же проверить поле error code! Код ошибки 0 означает, что ошибки нет. Просто вдумайтесь: код ошибки для отсутствия ошибки.
3. В-третьих, это поле может содержать число, строку, а иногда отсутствовать в ответе. Для каждого метода API поведение своё.
4. Ну и главное, что хотелось бы отметить, и что уже не получится исправить с помощью простенькой оберткой вокруг API: есть чуть меньше 10 возможных error code, и каждый из них включает целую группу ошибок. Конкретная же ошибка описывается в поле error message. Однако мы не можем с ним программно работать, чтобы на уровне системы определить конкретную ошибку, т.к. текст ошибки возвращается на языке пользователя `¯\_(ツ)_/¯`

## 7.

Ну хватит о грустном. Давайте поговорим о том, как всё делать хорошо.

Для каждой значимой фичи, связанной с Python, пишется PEP -- python enhancement proposal. Есть описание для самых разный вещей:

1. PEP-8. Самый известный PEP, описывающий общий стиль написания кода на Python. Какие должны быть отступы, длина строки и т.д.
1. PEP-20. Философские принципы, лежащие в основе Python, за которые мы так его любим. Например, "Явное лучше неявного"
1. PEP-537 описывает расписание релизов для Python 3.7. Такой есть для каждой минорной версии Python.
1. PEP-248 описывает единый интерфейс по работе с базами данных. Не важно, возьмете вы библиотеку для postgres, mysql или sqlite, в ней обязательно будут объекты connection и cursor, у cursor будет метод fetchone и т.д.

Собственно, это о важности стандартизации, описании единых интерфейсов перед написанием кода.

## 8.

А теперь поговорим о том, как же писать код. Для этого хочу рассказать о двух понятиях, которые мне кажутся ключевыми в этом вопросе: cohesion и coupling. Некоторые переводят их как "связность" и "связанность", чтобы побольше запутать аудиторию, но наша цель понять и разобраться, так что лучше не будем пытаться их переводить.

Cohesion показывает насколько сильно связаны элементы внутри отдельного модуля. Чем выше cohesion, тем лучше. Грубо говоря, не стоит всё запихивать в один класс. Например, у нас есть класс для того, чтобы делать http-запросы. Он должен уметь установить TLS-соединение, TCP-соединение, сформировать HTTP-заголовки для запроса. Мы можем всё это запихать в один класс, но гораздо лучше будет сделать отдельные классы для TCP, TLS и HTTP, а затем просто передать их в основной класс, чтобы он уже их использовал. Так будет гораздо проще работать с кодом.

Coupling же показывает насколько сильно связаны разные модули. Меньше -- лучше. Чем меньше связей между разными модулями, тем проще нам будет полностью заменить один из них.

## 9.

Ситуация: у нас есть два фрагмента кода, которые делают разные вещи, но какая-то логика у них всё-таки одинаковая. Например, это два разных метода нашего API, и для каждого запроса мы проверяем, что у пользователя есть права для доступа к этому методу, а для каждого ответа логируем результат. Есть много подходов к задаче, каждый из них разной степени извращенности и ориентированный на отдельные ситуации и языки. Я же сегодня хочу рассказать про три самых полезных: миксины, декораторы и аспектно-ориентированное программирование.

## 10.

Миксины есть только в тех языках, которые поддерживают множественное наследование. Python -- один из них. Миксины -- такие специальные классы, которые не могут использоваться сами по себе. Единственное, что они делают -- подмешивают  определенные методы к другим классам. Например, json response mixin в django, который перегружает у представления метод render to response. Добавляем миксин, и теперь представление будет рендерить не HTML шаблон, а json. Это удобно.

Ну или вот пример. У нас есть Адам, который человек. А человек, в свою очередь, примат. И в какой-то момент Адам становится не только человеком, но и машиной. Мы добавляем ему класс Machine, чтобы он теперь научился сигналить. И вот мы хотим, чтобы он издал какой-нибудь звук. Как думаете, что же он скажет? Кто за "Бип"? А за "Уук"?

## 11.

Правильный ответ "Уук". Потому что если мы посмотрим порядок, в котором Python будет искать нужный метод или атрибут, то первая ветка зависимостей окажется раньше. Поэтому первый полезный вывод: пишите миксины ДО основного родительского класса.

## 12.

А теперь пусть Machine тоже наследуется от Primate. Ну то есть Primate теперь общий родитель для Human и Machine. Как думаете, что будет? Кто за "Бип"? А за "Уук"?

## 13.

Да, теперь будет "Бип". Primate, который является общим родителем для Machine и Human, уехал в конец цепочки. Поэтому второй полезный вывод: миксины не должны ни от чего наследоваться. Даже от других миксинов.

## 14.

Это выглядит как чёрная магия, поэтому миксины всегда должны быть максимально легковесными и понятными.

Пример хорошего миксина: JsonResponseMixin, о котором я уже говорил ранее. Сразу понятно, что он делает и как делает: он переопределяет только один метод, и всё.

Плохие миксины:
1. MarketingMixin. Да, я видел миксин, который содержал больше десятка методов и нёс в себе почти всю логику маркетинга.
1. UserMixin. Какие методы он переопределяет? Я не знаю.
1. StaffMixin. Миксин, который наследуется от UserMixin. Мне в классе не нужен UserMixin, но StaffMixin его зачем-то тянет.

Если не хотите, чтобы ваш код напоминал чёрную магию, не делайте так.

## 15.

Что касается странного порядка разрешения наследования в Python, то тут всё оправдано. Дело в том, что все классы в python неявно наследуются от object, и этот общий родитель должен оказаться в самом конце порядка поиска атрибутов и методов. Сначала ищем в самом классе, потом во всех родителях, а потом уже реализацию по умолчанию в object.

## 16.

А теперь поговорим про декораторы. Я не буду рассказывать про основы, их вы можете легко найти в официальной документации. Гораздо интереснее конкретное применение декораторов, а именно контрактное программирование. Эта концепция позволяет довольно удобно и лаконично выносить валидацию данных из основного кода.

Контрактное программирование называется так, потому что какой-то фрагмент кода (функция или метод) заключает с остальной программой контракт, состоящий из трёх возможных типов условий: что внешний код передаст параметры, удовлетворяющие некоторым условиям, что сам фрагмент кода вернет результат в определенно заданных условиях и что внутреннее состояние фрагмента кода всегда будет соответствовать заданным условиям. Соответственно, есть три разных декоратора.

Давайте я просто покажу их на примере своего пакета deal.

1. `pre` валидирует значения, которые приходят в функцию извне. В данном примере начальная дата должна быть не больше конечной.
2. `post` валидирует ответ функции. Тут у нас проверяется, что ответ функции не falsy.

## 17.

3. Ну и `inv` (invariant) проверяет, что атрибут класса всегда удовлетворяет какому-то условию.

Контрактное программирование -- не замена тестам, а просто красивый способ вынести валидацию из основного кода.

## 18.

А теперь про аспектно-ориентированное программирование. Концепция в некоторой степени магическая, да и всяких хитрых терминов много, но разобраться в ней довольно просто. Итак, есть аспекты. Аспект -- это какой-то фрагмент кода. Класс, функция или модуль. Joinpoint -- точка, в которой один фрагмент кода вызывает другой. И в эту точку мы можем воткнуть Advice, который будет что-то делать. Например, логировать все вызовы или изменять результат вызова функции. Причём главное, что отличает такой подход от тех же декораторов: патчить можно сразу группу фрагментов кода. Например, все классы, которые содержат в названии слово View.

## 19.

Меньше слов, больше кода. Аспектных библиотек для Python довольно мало. Это вот пример использования самой адекватной из них, но она не умеет в паттерны аспектов, которые я назвал главным преимуществом AOP. Но она всё равно довольно удобная.

Вот мы задаём advice, который принимает joinpoint и выбирает, в какой момент её вызывать. А здесь мы с помощью weave подключаем advice к joinpoint. Weave переводится как "вплетать". Это ещё один термин AOP, которым обозначается подключения advice.

## 20.

И да, зачастую это выглядит как магия. Мы можем не понимать, почему класс ведет себя именно так, пока не найдем в совершенно другом модуле подключение advice. В то же время это бывает крайне полезно для того же логирования. И на самом деле, аспектное программирование в том или ином виде есть много где. Например, в Django это сигналы, где в качестве аспектов выступают модели базы данных, и промежуточные слои, где роль аспекта играет представление.

## 21.

А теперь, раз уж речь зашла про web, я хотел бы рассказать о конкретном паттерне разделения приложения на компоненты: MVC. Кто знает про MVC? Ну тогда кратко. MVC -- это когда мы разделяем приложение на Model, View и Controller. Пользователь взаимодействует с контроллером, который обрабатывает и валидирует все запросы, изменяет и получает данные из модели и формирует представление с результатами, которое видит пользователь.

## 22.

В Django всё несколько иначе. Когда только начинаешь изучать Django, то видится примерно такая картина: есть представление, которое делает вообще всё, реализует всю логику приложения, ну и взаимодействует с моделями. В принципе, в большинстве приложений всё выглядит вот именно так, но это вызывает вопросы: неужели так и должно быть?

## 23.

И с этим вопросом я отправился в Интернет. Нет, задумано не так. Тут предполагается то же MVC, только роль контроллера выполняет представление, а роль представления -- шаблон. А такая странная терминология, потому что всё это делает представление.

К сожалению, такой подход ведет иногда к грустным последствиям в крупных проектах. В одном legacy проекте нам досталось крайне критичное представления в тысячу строк, и это без учёта огромного количества миксинов.

## 24.

Именно благодаря тому проекту я ощутил необходимость жестко разделить толстые Django представления на отдельные этапы, каждый из которых будет легко сопровождать.

Итак, DjBurger реализует представление, которое реализует 8 этапов обработки запроса:
1. Декораторы оборачивают запрос, чтобы делать всякие удобные фичи. Например, проверка авторизации или отключение защиты от csrf. В Django слишком много мест, где можно декорировать представление. Лучше делать это явно в самом представлении.
1. Parser разбирает запрос. Это полезно, когда мы хотим в теле запроса присылать, например, JSON.
1. Pre-validator валидирует запрос. Если произошла ошибка валидации, pre-renderer вернет пользователю сообщение об ошибке.
1. Если всё хорошо, controller обработает запрос. Здесь реализована основная бизнес-логика.
1. Затем происходит post-валидация ответа контроллера. Это полезно как с точки зрения контрактного программирования, так и для вытаскивания из ответа контроллера полей, которые нужно вернуть пользователю.
1. Post-renderer формирует ответ при ошибке пост-валидации
1. Ну и renderer формирует ответ, когда всё хорошо.

WIP
